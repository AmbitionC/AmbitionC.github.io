## 4. HTTP & Networks

### 4.1 Web与网络基础

#### 4.1.1 网络基础TCP/IP

1. TCP(Transmission Control Protocal): 传输控制协议

- ***TCP位于传输层，提供可靠的字节流服务***

2. IP(Internet Protocal): 网际协议

- **位于网络层**

- IP地址与MAC地址

（1）IP地址：指明节点被分配的地址

（2）MAC地址：指网卡所属的固定地址

3. TCP/IP协议的分层管理

<center>

![4-1](https://ambitionc-blog.oss-cn-hongkong.aliyuncs.com/Blog_Notes/4HTTP%26NetWorks/4-1.png)

</center>

- 应用层：HTTP、SSH

- 传输层：TCP、UDP、TLS

- 网络层：IP、BGP

- 网络接口层（链路层）

4. 三次握手

- 确保准确无误地将数据送达目的

- ***TCP的标志(flag) ——SYN(synchronize)和ACK(acknowlegement)***

- 三次握手流程：

（1）客户端向服务器发送SYN

（2）服务器向客户端回应ACK与SYN

（3）客户端向服务器回应ACK

5. URI(Uniform Resource Identifier)和URL(Uniform Resource Location)

- URL 属于 URI

### 4.2 简单的HTTP协议

1. HTTP协议用于客户端与服务器之间的通信

2. 通过请求和响应的交换来达成通信

3. HTTP是不保存状态（无状态）的协议

- 无状态协议是指HTTP协议不对请求和响应之间的通信状态进行保存，也就是每一次的请求与之前的请求无关。也就是每一次有新的请求就会有新的响应产生。

4. 告知服务器意图的HTTP方法

- GET: 获取资源

（1）指定的资源经服务器端解析后返回响应内容

- POST: 传输实体主体

（1）用来传输实体的主体

- PUT: 传输文件

（1）用来传输文件，像FTP协议的文件上传一样，要求在报文的主体包含文件内容

- HEAD: 获得报文首部

- DELETE: 删除指定的资源

- OPTIONS: 询问支持的方法

- TRACE: 追踪路径

5. 持久连接以节省通信量

- TCP建立与断开需要通信量的开销

- 持久连接：只要任意一端没有明确提出断开连接，则保持TCP连接状态

6. 管线化(pipelining): 不用等待响应即可直接发送下一个请求

***7. 使用Cookie进行状态管理***

- Why: HTTP协议是一种无状态协议，无法根据之前的状态进行本次的请求处理

- How: Cookie技术通过在请求和报文中写入Cookie信息来控制客户端状态

### 4.3 HTTP报文内的HTTP信息

#### 4.3.1 HTTP报文

<center>

![4-2](https://ambitionc-blog.oss-cn-hongkong.aliyuncs.com/Blog_Notes/4HTTP%26NetWorks/4-2.png)

</center>

1. 请求行：请求URI和HTTP版本

2. 状态行：响应原因短语和HTTP版本

3. 首部字段：包含请求与响应的各种条件和属性的各类首部

4. 其他：Cookie等

#### 4.3.2 编码提升传输效率

1. 压缩传输的内容编码

2. 分割发送的分块传输编码

#### 4.3.4 内容协商以返回合适的内容

1. 服务器驱动协商：由服务器进行内容协商，在服务器端自动处理

2. 客户端驱动协商：客户端进行内容协商的方式，按OS的类型自行切换PC版本或手机版本

3. 透明协商：服务器驱动和客户端驱动的结合体

### 4.4 HTTP状态码

#### 4.4.1 2XX成功

1. 200 OK: 请求已正常处理

2. 204 No Content: 返回的响应报文中不含有实体的主体成分

3. 206 Partial Content: 范围请求

#### 4.4.2 3XX重定向

1. 301 Moved Permanently: 永久性重定向，资源被分配了新的URI

2. 302 Found: 临时性重定向，请求的资源已被分配了新的URI

3. 303 See Other: 临时性重定向，采用Get方式

4. 304 Not Modified: 资源未改变，可以直接用缓存

5. 307 Temporary Redirect: 临时重定向

#### 4.4.3 4XX 客户端错误

1. 400 Bad Request: 报文语法错误

2. 401 Unauthorized: 需要有通过HTTP认证的认证信息

3. 403 Forbidden: 请求资源被服务器拒绝

- 可能原因：未获得文件系统的访问授权；访问权限出现某些问题

4. 404 Not Found: 服务器上无法找到请求的资源

#### 4.4.4 5XX 服务器错误

1. 500 Internal Server Error: 服务器端执行请求的时候发生错误

2. 503 Service Unavailable: 服务器暂时处于超负载或停机维护

### 4.5 与HTTP协作的Web服务器

#### 4.5.1 虚拟主机

虚拟主机可以用来实现一台HTTP服务器搭建多个Web站点，如提供Web托管服务

```
主机名/域名 --- DNS --- IP地址
```

Host首部包含：完整的主机名/域名的URI

#### 4.5.2 通信数据转发程序

1. 代理：实现转发功能

- 代理服务器基本行为：接收客户端的请求后，转发给其他服务器（转发时需要附加Via首部字段以标记经过的主机信息）

- 使用代理服务器的理由：
（1）利用缓存减少网络带宽的流量
（2）组织内部针对特定网站访问控制，以获取访问日志

- 缓存的分类：
（1）缓存代理（Caching Proxy）资源副本保存在代理服务器上 
（2）透明代理（Transparent Proxy）转发请求或响应不对报文加工

2. 网关：转发其他服务器通信数据的服务器

- 利用网关可提高通信的安全性，因为可以在客户端与网关之间通信线路上加密以确保连接的安全

3. 隧道：保持双方通信连接的应用程序

- 可以和远距离的服务器安全通信，隧道本身透明

#### 4.5.3 保存资源的缓存

- 利用缓存可以节省通信流量和通信时间，避免多次从原服务器转发资源

- 缓存的有效期限

- 客户端的缓存

### 4.6 HTTP首部

HTTP首部我们一般会关注首部的结构以及各个字段的用法

#### 4.6.1 HTTP报文首部

HTTP报文首部主要是为客户端和服务器端分别处理请求和响应提供所需要的信息

1. HTTP请求报文组成

- 方法：POST、GET...

- URI：Uniform Resource Identifier 统一资源标识符

- HTTP版本：1.1 / 2.0...

- HTTP首部字段等

2. HTTP响应报文组成

- HTTP版本
- 状态码：采用数字或原因短语等
- HTTP首部字段

#### 4.6.2 HTTP首部字段

1. HTTP首部字段作用：
 - 为浏览器和服务器端提供报文主体大小、所使用的语言、认证信息等内容

2. HTTP首部字段结构：

```
首部字段名: 字段值
```

3. 4种HTTP首部字段类型

（1）通用首部字段

- **Cache-Control: 控制缓存行为**
- Via: 代理服务器的相关信息

（2）请求首部字段

- Accept: 用户代理可处理的媒体类型，也就是客户端可以接受的媒体类型
- If-Match/If-None-Match: 比较实体标记(ETag)
- If-Modified-Since/If-Unmodified-Since: 比较资源的更行时间

（3）响应首部字段

- ETag: 资源的匹配信息
- Accept-Ranges: 是否接受字节范围请求

（4）实体首部字段

- Allow: 资源可支持的HTTP方法
- Last-Modified: 资源最后的修改时间

4. 非HTTP/1.1首部字段

- Cookie
- Set-Cookie
- Content-Disposition

5. 端到端首部和逐跳首部

- 端到端(End-to-end)首部：发给请求或响应的最终的接受目标，且保存在由缓存生成的响应中，规定其必须被转发

- 逐跳(Hop-by-hop)首部：只对单次转发有效，

#### 4.6.3 HTTP/1.1通用首部字段

1. ***Cache-Control***

操作缓存机制，常用指令：
（1）缓存请求指令

- no-cache: 强制向源服务器再次验证（客户端不会缓存）
- no-store: 不缓存请求或响应的任何内容（针对请求或响应的内容）
- max-age = [秒]: 响应的最大Age值

（2）缓存响应指令

- public: 可向任意方提供响应的缓存
- private: 仅向特定用户返回响应
- no-cache: 缓存前必须确认其有效性
- no-store: 不缓存请求或响应的任何内容
- max-age = [秒]: 响应的最大Age值
- s-maxage = [秒]: 公共缓存服务器响应的最大Age值

（3）能否缓存的指令

- public指令

```
Cache-Control: public
```
表示其他的用户也可以利用缓存（缓存功能公有化）

- private指令

```
Cache-Control: private
```
响应只以特定的用户作为对象，缓存服务器会对该特定用户提供资源缓存的服务（缓存功能私有化）

（4）no-cache指令
```
Cache-Control: no-cache
```
***no-cache作用：为了防止从缓存中返回过期的资源***

- 如果客户端发送的请求中如果包含no-cache指令，则表示客户端将不会接收缓存过的响应

- 如果服务器返回的响应中包含no-cache指令，那么缓存服务器不能对资源进行缓存，源服务器也不会确认

- Cache-Control可以对no-cache字段名具体指定参数值，那么被指定的参数值的首部字段响应报文后，就不能使用缓存。（只能在响应指令中指定该参数）

（5）no-store指令
```
Cache-Control: no-store
```

***no-store作用：暗示请求和对应的响应中包含机密的信息***

- 该指令规定不能在本地 存储请求或响应的任一部分

（6）***no-cache与no-store区别***

- no-cache表示的不是不缓存的意思，事实上no-cache代表不缓存过期的资源，缓存会向源服务器进行有效确认后处理资源。no-cache被认为是do not server from cache without revalidation更合适。其实意思就是不使用没有经过确认后（过期）的资源

- no-store才是表示不进行缓存

（7）max-age指令
```
Cache-Control: max-age=604800（单位：秒）
```
作用：

```
graph LR
客户端:判断缓存是否过期,没过期则直接获取-->缓存服务器
缓存服务器-->源服务器:时间范围内不向源服务器确认,直接支配
```

```
客户端——（判断缓存是否过期，没过期则直接获取）——>缓存服务器<——（时间范围内不向源服务器确认，直接支配）——源服务器
```
指定max-age为0，缓存服务器需要将请求转发给源服务器

（8）s-maxage指令
```
Cache-Control: s-maxage=604800
```
- 指令功能与max-age相同，但是该指令适用于多个用户使用的公共缓存服务器

（9）must-revalidate指令
```
Cache-Control: must-revalidate
```

- 作用：代理会向源服务器再次验证即将返回的响应缓存是否仍然有效

2. Connection

Connection作用：
- 控制不再转发给代理的首部字段，例如：
```
Get / HTTP / 1.1
Upgrade: HTTP/1.1
Connection: Upgrade
```
代理服务器将不会转发首部字段为Upgrade内容

- 管理持久连接（Keep-Alive / Close）

3. Upgrade

Upgrade作用：用于检测HTTP协议及其他协议是否可使用更高的版本通信


#### 4.6.4 请求首部字段

1. Accept

- 可通知服务器，用户代理能够处理的媒体类型及媒体类型的相对优先级（优先级通过设置权限来实现）

2. Authorization

- 首部字段Authorization: 告知服务器，用户代理的认证信息（证书值）

3. Host

- 虚拟主机和服务器都运行在同一个IP上，使用首部字段Host来加以区分

- 首部字段Host会告知服务器，请求的资源所处的互联网主机名和端口号

If-xxx形式的请求都可称为条件请求

4. If-Match

- 告知服务器匹配资源所用的实体标记(ETag)值，服务器会对比If-Match的字段值和资源的ETag值，仅当两者一致，才会执行请求

5. If-Modified-Since
```
If-Modified-Since: Thu, 15 Apr 2004 00:00:00 GMT
```
- 用于确认代理或客户端拥有的本地资源的有效性

- 判断请求的资源是否更新，如没有，返回状态码304 Not Modified


6. If-None-Match

- 与If-Match相反，其字段值与实体标记(ETag)不同时，告知服务器处理该请求

7. If-Range

- 告知服务器指定的范围，如和请求的资源的ETag值或时间一致时，作为范围请求处理，否则返回全体资源

8. If-Unmodified-Since

- 和If-Modified-Since相反，如在时间段内，未发生更新，才能处理请求

9. Range
```
Range: bytes=5001 - 10000
```

 - 对于只需获取部分资源的范围请求

返回情况：
- 处理请求后返回状态码为206 Partical Content的响应
- 无法处理该范围请求：返回状态码200OK的响应及全部资源

10. User-Agent

- 将创建请求的浏览器和用户代理名称等信息传达给服务器

#### 4.6.5 响应首部字段

1. Accept-Ranges
```
Accept-Ranges: bytes
```
作用：告知客户端服务器能否处理范围请求，可处理返回bytes，不可处理则指定为none

**2. Age**
```
Age: 600
```

- 首部字段Age能够告知客户端，源服务器多久前创建了响应

- Age值是指缓存后的响应再次发起认证到认证完成的时间值
```
客户端<======>缓存服务器    源服务器
```


通俗的说，Age表示从缓存服务器的缓存上次向源服务器验证时间起，到这次发起认证过去的时间

**3. ETag**

ETag作用：告知客户端的实体标识，将资源以字符串的形式作为唯一性标识的方式

- 资源的URI虽然相同，但是不同版本的资源是不同的

（1）强ETag: 实体发生任何变化都会改变值
```
ETag: "usagi-1234"
```
（2）弱ETag: 用于提示资源是否相同，只有根本改变，才会改变ETag值
```
ETag: W/"usagi-1234"
```

**4. Location**

Location作为响应首部字段，发生在客户端的请求地址发生改变的情况下，如请求的页面URI改变，则服务器会响应Location，字段内容即为不同位置的资源，该字段会配合3xx: Redirection的响应合作

```
302 Found
Location: http://www.usagidesign.jp/sample.html
```

5. Proxy-Authenticate

在客户端与代理之间进行的HTTP访问认证的行为

**6. Retry-After**
```
Retry-After: 120
Retry-After: Wed, 04 Jul 2012 ...
```
- 告知客户端在多久之后再次发送请求
- 配合状态码503 Service Unavailable响应或3xx Redirect响应一起使用
- 可以为具体的秒数，也可以是具体的时间

7. Server
```
Server: Apache/2.2.17(Unix)
```
告知客户端当前服务器上安装的HTTP服务器应用程序的信息

8. Vary

```
graph LR
客户端Accept-Language-->代理服务器Accept-Language
代理服务器Accept-Language-->源服务器Vary:Accept-Language
```

```
Vary: Accept-Language
```

- 如果源服务器向代理服务器响应的首部字段中含有Vary时，Vary字段会指定获取的资源，如使用的Accept-Language字段的值相同，那就从缓存返回响应。否则，需要先从源服务器获取资源后才能作为响应返回

- Vary可以对缓存进行控制

#### 4.6.6 实体首部字段

实体首部字段就是包含在请求报文和响应报文的实体部分所使用的首部

**1. Allow**

```
Allow: GET, HEAD
```

- 表示支持Request-URI指定资源的所有HTTP方法

2. Content-Encoding

```
Content-Encoding: gzip/compress/deflate/identity
```

- 主体选用的内容编码方式

3. Content-Language

- 实体使用的自然语言

4. Content-Length

- 实体主体的大小，单位是字节

**5. Content-Location**

- 表示报文主体返回资源对应的URI，和首部字段Location不同，Location是在3xx Redirection 的情况下，在客户端请求的地址发生改变的情况下，返回Location，Location的内容是资源的实际URI

6. Content-MD5

- 内容是一串由MD-5算法生成的值，其目的是检查报文主体在传输过程中是否保持完整

7. Content-Range

```
Content-Range: bytes 5001 - 10000 / 10000
```

- 告知客户端作为响应范围的实体符合范围请求的部分
- 发生在客户端请求部分资源的情况下

8. Content-Type

- 说明实体内对象的媒体类型

9. Expires

```
Expires: Wed, 05 Jul 2012 08:25:05 GMT
```

- 告知客户端资源失效的日期
- 超过指定时间会，缓存服务器会向源服务器请求资源
- 比起首部字段Expires, 优先处理max-age指令

**10. Last-Modified**

- 指明资源最终修改的实际
- 如使用CGI脚本进行动态数据处理时，该值变成数据最终修改时的时间

#### 4.6.7 为Cookie服务器的首部字段

***Cookie: 管理服务器和客户端之间的状态***

***Cookie的工作机制是用户识别和状态管理***

比如在同一个网站中的分级页面，用户登陆状态得保持一致，为了避免重复登陆，会使用Cookie

为Cookie服务的首部字段主要是：

- ***Set-Cookie: 开始状态管理所使用的Cookie信息***

- ***Cookie: 服务器接收到的Cookie信息***

1. Set-Cookie（响应首部字段）

- NAME=VALUE 赋予Cookie的名称和其值

- expires=DATE Cookie的有效期，若不明确则直到浏览器关闭

- path=PATH 服务器上文件目录作为Cookie的适用对象

- domain=域名 作为Cookie适用对象的域名

- Secure 仅在HTTPS安全通信时才会发送Cookie

- **HTTPOnly Cookie不能被JS脚本访问，主要是为了防御跨站脚本攻击(Cross-site scripting, XSS)对Cookie的信息窃取**XSS利用JavaScript劫持Cookie

2. Cookie（请求首部字段）

- 首部字段Cookie会告知服务器，当客户端想获得HTTP状态管理支持时，会在请求中包含从服务器接收到的Cookie

#### 4.6.8 其他首部字段

1. X-Frame-Option: 防止点击劫持攻击

2. X-XSS-Protection: 针对跨站脚本攻击的一种对策，控制浏览器XSS防护机制的开关

XSS：Cross-site scripting, 利用JS脚本对Cookie劫持，应对方法：首部字段Set-Cookie的HTTPOnly属性，X-XSS-Protection设置

3. DNT: Do not Track拒绝个人信息被收集

4. P3P: 保护用户隐私

### 4.7 确保Web安全的HTTPS

#### 4.7.1 HTTP缺点

1.***通信使用明文（不加密），内容可能会被窃听***

- 通信的加密：SSL(Secure Socket Layer, 安全套接层)或TLS(Transport Layer Security, 安全传输协议)组合使用

- 内容的加密：这样仍有被篡改的风险

2. ***不验证通信方的身份，可能遭遇伪装***

- 无法确定正在通信的对方的是否具有访问权限

3. ***无法证明报文的完整行，所以有可能被篡改***

- 中间人攻击(Man-in-the-Middle attack, MITM): 请求或响应传输途中，遭攻击者拦截并篡改内容的攻击

- 防止篡改：常采用MD5和SHA-1等散列值校验的方法

#### 4.7.2 HTTPS

***HTTPS = HTTP + 加密 + 认证 + 完整性保护***

1. SSL

- HTTP通信接口用SSL(Secure Socket Layer, 安全套接层)和TLS(Transfer Layer Secure, 传输安全协议)

2. 公开密钥加密

- 相互交换密钥的公开密钥加密技术

- 公开密钥加密使用一对**非对称**的密钥

- 发送密文的一方，采用公开密钥加密，对方收到后再使用私有密钥解密

- 解密过程是对离散对数进行求值

3. ***HTTPS采用共享密钥加密和公开密钥加密两者并用的混合加密机制***

4. 为了保证公开的密钥正确，引入**第三方数字证书认证机构**，对公开密钥部署**数字签名**，颁发**公钥证书**。

5. ***HTTPS安全通信过程***

- SSL握手协商部分，主要通过报文形式

- 客户端与服务器发送报文，主要进行校验，最终建立SSL(Secure Socket Layer)连接

- 应用层协议通信，断开连接

6. SSL会大幅提升网络与硬件的负载压力，因此，在部分个人信息等敏感数据的部分，会用到HTTPS

### 4.8 确认访问用户身份的认证

Web页面实现特定的用户群浏览，就需要采用认证机制

#### 4.8.1 HTTPS认证的方式

***认证就是让客户端自报家门，便于服务器认证***

1. BASIC认证（基本认证）

- BASIC认证是客户端与服务器之间进行认证的方式，BASIC认证采用Base64编码方式，但不是加密处理，直接发送明文密码，安全性问题较大

2. DIGEST认证（摘要认证）

- 采用质询/响应的方式，发送的是质询码与响应码的计算结果，安全性提升

<center>

![4-3](https://ambitionc-blog.oss-cn-hongkong.aliyuncs.com/Blog_Notes/4HTTP%26NetWorks/4-3.png)

</center>



- 可以防窃听，但是不能防止用户伪装的保护机制

3. SSL客户端认证

- 客户端需要提前安装客户端证书

- 基本步骤就是，服务器先发送Certificate Request报文，要求客户端提供客户端证书。然后客户端将证书信息以Client Certificate报文方式发送给服务器。最后服务器验证通过后领取客户端的公开密钥，然后开始HTTPS加密通信。

4. FormBase认证（基于表单认证）

- SSL通常因为费用问题，尚未普及

- 超过半数的采用FormBase

5. ***Session管理与Cookie应用***

- 一般使用Cookie来管理Session（会话）

- 将客户端发送过来的用户ID和密码与之前登陆过的信息来做匹配进行认证

- ***HTTP是一种无状态的协议***

无状态协议表示每次的请求都和之前的请求独立，无状态的设计简化了服务器端的设计，不必动态分配存储空间处理进行中的会话，系统不必为清理服务器状态而做出响应。因此，服务器想要得到客户端的登陆状态等情况时，就需要包含cookies等带有状态的数据

- 使用Cookie来管理Session，以弥补HTTP协议中不存在的状态管理功能

### 4.9 基于HTTP的功能追加协议

#### 4.9.1 SPDY: 消除HTTP瓶颈

1. SPDY缩短Web页面的加载时间（50%）

2. HTTP的瓶颈有以下：

- 一条连接只可以发送一个请求

- 请求只能从客户端发起。客户端不能接收除响应以外的指令

- 请求/响应未经过压缩就发送，首部信息越多延迟越大

- 发送冗长的首部，每次发送相同的首部，浪费较多

- 可任意选择数据压缩格式，非强制压缩发送

***3. Ajax(Asynchronous JavaScript and XML, 异步JavaScript与XML技术)，是一种有效利用JavaScript和DOM的操作，达到局部Web页面替换加载的异步通信手段***

- Ajax实时从服务器获取内容，可能会导致大量请求产生，Ajax未能解决HTTP协议本身的问题

***4. Comet***

- What: Comet是一种通过延迟应答，模拟实现服务器端向客户端推送(Server Push)的功能

- How: Comet为了实现推送的功能，会将响应置于挂起的状态，当服务器端有更新的时候，再返回响应

- Why: 使用Comet实现服务推送，为了保留响应，一次连接的持续时间也变长了。为了维持连接会消耗更多的资源，Comet未能解决HTTP的问题

***5. SPDY: HTTP协议层面上的改动***

- How: SPDY在TCP/IP的应用层与传输层之间通过新加会话层的形式运作

- **多路复用流**：通过单一的TCP连接，可以无限制处理多个HTTP请求

- **赋予请求优先级**：设置优先级顺序，解决因带宽低而导致响应变慢的问题

- **压缩HTTP首部**：减少数据包和发送的字节数

- **推送功能**：主动发送数据并非等待客户端请求

- **服务器提示功能**：如果资源已经缓存，则会给出提示，避免发送不必要的请求

#### 4.9.2 WebSocket: 使用浏览器进行全双工通信

1. WebSocket是基于HTTP协议的通信标准

2. 确立WebSocket连接后，无论服务器端还是客户端，任意一方都可以直接向对方发送报文

3. 连接建立后，只需要完成一次“握手”

4. WebSocket 采用独立的数据帧

#### 4.9.3 HTTP2.0

1. HTTP2.0用于改善并提高移动通信时的通信速度和性能

2. 建立在Google公司的SPDY和WebSocket的基础上

#### 4.9.4 WebDAV: Web服务器管理文件

1. WebDAV(Web-based Distributed Authoring and Versioning, 基于万维网的分布式创作与版本控制)

2. WebDAV实现内增的方法与状态码，因为WebDAV是在服务器端上的资源管理的系统，除了基本的修改删除等操作，也会有多人协作等情况出现。因此，这些状态码和方法就能够针对这些应用场景做出相应的

### 4.10 Web攻击技术

针对Web站点的攻击技术，HTTP协议本身安全性较低

#### 4.10.1 在客户端即可篡改请求

1. 在HTTP请求报文中加载攻击代码，通过URL查询字段或表单、HTTP首部、Cookie等途径将攻击代码传入

**2. 以服务器为目标的主动攻击：直接访问Web应用，把攻击代码传入**

- SQL注入攻击

- OS命令注入攻击

**3. 以服务器为目标的被动攻击**

- 攻击者不直接对目标Web应用访问发起攻击，窃取用户所持有的Cookie等个人信息被窃取

- 利用用户的身份攻击企业内部网络

#### 4.10.2 因输出值转义不完全引发的安全漏洞

***1. 跨站脚本攻击(XSS)***

- 跨站脚本攻击(Cross-Site Scripting, XSS)通过存在安全漏洞的Web网站注册用户浏览器内运行非法的HTML标签或JavaScript进行的一种攻击

- 造成影响：

（1）利用虚假输入表单骗取用户个人信息

（2）利用脚本窃取用的Cookie值，用户不知情的情况下，为攻击者发送恶意请求

（3）显示伪造的文章或图片

- XSS通过预先设置的陷阱触发的被动攻击：可能会以邮件、链接的形式发送给用户，在其中嵌入恶意的代码，导致个人登陆信息被窃取，或者窃取用户的Cookie信息

***2. SQL注入攻击***

- SQL注入攻击是针对Web应用的数据库，通过运行非法的SQL而产生的攻击

- SQL注入攻击会造成一下影响：

（1）非法查看或篡改数据库内的数据

（2）规避认证

（3）执行和数据库服务器业务关联的程序等

- 实际发生SQL注入攻击时，导致用户信息或结算内容等数据表被浏览或篡改

3. OS命令注入攻击

- 执行非法操作系统命令达到攻击目的，只要在能调用Shell函数的地方就有被攻击的风险

4. **HTTP首部注入攻击**

- HTTP首部注入攻击是攻击者在响应首部字段插入换行，添加任意响应首部或主体的一种攻击。属于**被动攻击**模式

- 可能造成影响：

（1）设置任何Cookie信息

（2）重定向至任意URL

（3）显示任意的主体（HTTP响应截断攻击：向首部主体内添加内容的攻击）

- **HTTP首部注入攻击**通常的操作方式为，在HTTP首部插入 %0D%0A 即在HTTP报文中为换行符，后面添加新的字段，如Set-Cookie: +SID=123456789, Set-Cookie生效，攻击者则可以指定修改任意的Cookie信息

- **HTTP响应截断攻击**通常的操作为，将两个 %0D%0A%0D%0A 并排插入字符串后发送，就可以作出HTTP首部与主体分隔所需要的空行，就可以显示伪造的主体，达到攻击的目的

5. 邮件首部注入攻击

- Web应用中的邮件发送的功能，攻击者向邮件首部To或Subject内任意添加非法内容引起的攻击

6. 目录遍历攻击

- 目录遍历攻击指对本无意公开的文件目录，通过非法截断后达到访问目的的一种攻击，也称为路径遍历攻击

#### 4.10.3 因设置或设计上的缺陷引发的安全漏洞

1. 强制浏览：强制浏览的安全漏洞指的是从安置在Web服务器的公开目录下的文件中，浏览那些原本非自愿公开的文件

- 造成的影响：

（1）泄漏顾客的个人信息等情报

（2）泄漏原本有访问权限的用户才能查阅的信息的内容

（3）泄漏未外链到外界的文件

2. 不正确的错误消息处理：Web应用错误信息包含对攻击者有用的信息

（1）Web应用抛出的错误

- 比如，用户在登陆的过程中，可能出现邮箱输入错误和密码输入错误的情况，不同的情况，服务器端会给出不同的响应，攻击者可以通过不同的错误信息确认邮箱地址是否注册等

（2）数据库等系统抛出的错误消息

- 攻击者可能看到部分数据库语句等

3. 开放重定向：重定向的URL到有恶意的Web网站

- 选择开放重定向功能的Web可能会被选中作为钓鱼攻击的跳板

#### 4.10.4 会话管理疏忽引发的安全漏洞

1. 会话劫持：是指攻击者通过某种手段拿到了用户的会话ID，并且非法使用此会话ID伪装成用户，达到攻击的目的

2. 获取会话ID的途径

- 通过非正规的生成方式推测会话ID

- 通过窃听或XSS攻击盗取会话ID

- 通过会话固定攻击(Session Fixation)强行获取会话ID

（1）**会话固定攻击**会强制用户使用攻击者指定的会话ID，属于**被动攻击**

3. ***跨站点请求伪造(Cross-site Request Forgeries, CSRF)***

- 攻击者通过设置好的陷阱，强制对已完成认证的用户进行非预期的个人信息或设定信息等某些状态进行更新，属于**被动攻击**

#### 4.10.5 其他安全漏洞

1. 密码破解

- 穷举法

- 字典攻击

2. 对已加密密码的破解

- 密码保存形式通过散列函数或加salt手段对要保存的密码本身加密

3. 点击劫持(Clickjacking)

- 是指利用透明的按钮或链接做成陷阱，覆盖在web之上

4. ***DoS攻击(Denial of Service attack)***

DoS攻击是一种让运行中的服务呈停止状态的攻击

- 集中利用访问请求造成资源过载，资源用尽的同时，实际上服务也就呈停止状态

- 通过攻击安全漏洞使服务停止